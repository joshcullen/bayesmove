% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segmentation_gibbs_sampler.R
\name{segment_behavior}
\alias{segment_behavior}
\title{Segmentation model to estimate breakpoints}
\usage{
segment_behavior(
  data,
  ngibbs,
  nbins,
  alpha,
  breakpt = purrr::map(names(data), ~NULL)
)
}
\arguments{
\item{data}{A list where each element stores the data for a separate animal
ID. List elements are data frames that only contain columns for the animal
ID and for each of the discretized movement variables.}

\item{ngibbs}{numeric. The total number of iterations of the MCMC chain.}

\item{nbins}{numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
\code{data}.}

\item{alpha}{numeric. A single value used to specify the hyperparameter for
the prior distribution. A standard value for \code{alpha} is typically 1,
which corresponds with a vague prior on the Dirichlet distribution.}

\item{breakpt}{A list where each element stores a vector of breakpoints if
pre-specifying where they may occur for each animal ID. By default this is
set to \code{NULL}.}
}
\value{
A list of model results is returned where elements include the
  breakpoints, number of breakpoints, and log marginal likelihood at each
  iteration of the MCMC chain for all animal IDs. The time it took the model
  to finish running for each animal ID are also stored and returned.
}
\description{
This function performs the reversible-jump MCMC algorithm using a Gibbs
sampler, which estimates the breakpoints of the movement variables for each
of the animal IDs. This is the first stage of the two-stage Bayesian model that
estimates proportions of behavioral states by first segmenting individual
tracks into relatively homogeneous segments of movement.
}
\details{
This model is run in parallel using the \code{future} package. To ensure that
the model is run in parallel, the \code{\link[future]{plan}} must be used
with \code{multisession} as the argument for most operating systems.
Otherwise, model will run sequentially by default if this is not set before
running \code{segment_behavior}.
}
\examples{
#simulate data
step<- rgamma(1000, c(1, 2.5, 10), c(1, 1, 1))
angle<- runif(1000, -pi, pi)
date<- seq(c(ISOdate(2020, 6, 17, tz = "UTC")), by = "hour", length.out = 1000)
date<- date + lubridate::seconds(runif(length(date), -15, 15))  #introduce noise
dt<- as.numeric(diff(date)) * 60  #convert time difference to seconds
dt<- c(dt, NA)
var<- rep(sample(c(1,2), 100, replace = TRUE), each = 10)
id<- rep(1:10, each = 100)


#create data frame and round time
dat<- data.frame(id, date, dt, step, angle, var)
dat<- round_track_time(dat = dat, id = "id", dt = "dt", date = "date",
                       int = 3600, tol = 15)


#define limits for each bin
dist.lims<- c(quantile(step, c(0, 0.25, 0.5, 0.75, 0.95)), max(step))  #5 bins
angle.lims<- c(-pi, -3*pi/4, -pi/2, -pi/4, 0, pi/4, pi/2, 3*pi/4, pi)  #8 bins

#discretize step and angle
dat1<- discrete_move_var(dat = dat, lims = list(dist.lims, angle.lims),
                         varIn = c("step", "angle"),
                         varOut = c("SL","TA"))


#create list and filter by primary time step
dat.list<- df_to_list(dat = dat1, ind = "id")
dat.list.filt<- filter_time(dat.list = dat.list, dt = "dt", tstep = 3600)


#find breakpoints to pre-specify by ID
breaks<- lapply(dat.list.filt, find_breaks, ind = "var")






#perform segmentation w/o pre-specifying breakpoints
dat.list.filt1<- lapply(dat.list.filt,
                        function(x) subset(x, select = c(id, SL, TA)))
future::plan(future::multisession)
dat.res1<- segment_behavior(data = dat.list.filt1, ngibbs = 1000, nbins = c(5,8),
                            alpha = 1)


#perform segmentation w/ pre-specifying breakpoints
dat.list.filt2<- lapply(dat.list.filt,
                        function(x) subset(x, select = c(id, SL, TA, var)))
future::plan(future::multisession)
dat.res2<- segment_behavior(data = dat.list.filt2, ngibbs = 1000, nbins = c(5,8,2),
                            alpha = 1, breakpt = breaks)

future::plan(future::sequential)

}
